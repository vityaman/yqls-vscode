{
    "TakeWhileInclusive": "**Аргументы**:\n\n| collection | predicate |\n| --- | --- |\n| List<T> | Callable(T) -> Bool |\n\n**Возвращаемое значение**: List<T>\n\nВозвращает элементы с начала списка, пока `predicate` возвращает `True`, **включая первый элемент, для которого `predicate` стал `False`**.\n\n```yqls\n(let nums (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3) (Uint32 '4) (Uint32 '5) (Uint32 '2)))\n(let result (TakeWhileInclusive nums (lambda '(x) (< x (Uint32 '4)))))\n-- результат: [1, 2, 3, 4]\n```\n\n---",
    "SkipWhileInclusive": "**Аргументы**:\n\n| collection | predicate |\n| --- | --- |\n| List<T> | Callable(T) -> Bool |\n\n**Возвращаемое значение**: List<T>\n\nПропускает элементы с начала, пока `predicate` возвращает `True`, **включая первый элемент, для которого `predicate` вернул `False`**.\n\n```yqls\n(let nums (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3) (Uint32 '4) (Uint32 '5) (Uint32 '6)))\n(let result (SkipWhileInclusive nums (lambda '(x) (< x (Uint32 '4)))))\n-- результат: [5, 6]\n```\n\n---",
    "FlatMap": "**Аргументы**:\n\n| collection | transformer |\n| --- | --- |\n| List<T> | Callable(T) -> List<R> |\n\n**Возвращаемое значение**: List<R>\n\nПрименяет `transformer` к каждому элементу и объединяет результаты в один плоский список.\n\n```yqls\n(let lists (AsList\n    (AsList (Uint32 '1) (Uint32 '2))\n    (AsList (Uint32 '3))\n    (AsList (Uint32 '4) (Uint32 '5))\n))\n(let result (FlatMap lists (lambda '(x) x)))\n-- результат: [1, 2, 3, 4, 5]\n```\n\n---",
    "OrderedFlatMap": "**Аргументы**:\n\n| collection | transformer |\n| --- | --- |\n| List<T> | Callable(T) -> List<R> |\n\n**Возвращаемое значение**: List<R>\n\nАналог `FlatMap`, но гарантирует **сохранение порядка** элементов даже при параллельной обработке.\n\n```yqls\n(let items (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3)))\n(let result (OrderedFlatMap items (lambda '(x)\n    (AsList x (Add x (Uint32 '1)))\n)))\n-- результат: [1, 2, 2, 3, 3, 4]\n```\n\n---",
    "StaticMap": "**Аргументы**:\n\n| collection | mapping |\n| --- | --- |\n| List<T> | Dict<T, R> |\n\n**Возвращаемое значение**: List<Optional<R>>\n\nПреобразует каждый элемент по словарю. Если элемент отсутствует в словаре — результат `None`.\n\n```yqls\n(let keys (AsList (String 'Alice) (String 'Bob) (String 'Charlie)))\n(let dict (AsDict\n    (AsTuple (String 'Alice) (String 'A))\n    (AsTuple (String 'Bob) (String 'B))\n))\n(let result (StaticMap keys dict))\n-- результат: [Just(\"A\"), Just(\"B\"), None]\n```\n\n---",
    "StaticZip": "**Аргументы**:\n\n| collection1 | collection2 | ... |\n| --- | --- | --- |\n| List<T1> | List<T2> | ... |\n\n**Возвращаемое значение**: List<Tuple<T1, T2, ...>>\n\nСоединяет списки по индексам. Длина результата — по самому короткому.\n\n```yqls\n(let nums (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3)))\n(let letters (AsList (String 'a) (String 'b) (String 'c) (String 'd)))\n(let result (StaticZip nums letters))\n-- результат: [(1,\"a\"), (2,\"b\"), (3,\"c\")]\n```\n\n---",
    "Sort": "**Аргументы**:\n\n| collection | [comparator] |\n| --- | --- |\n| List<T> | Callable(T, T) -> Int |\n\n**Возвращаемое значение**: List<T>\n\nСортирует список. Без `comparator` — по естественному порядку.\n\n```yqls\n(let unsorted (AsList (Int32 '3) (Int32 '1) (Int32 '4) (Int32 '1) (Int32 '5)))\n(let sorted (Sort unsorted))\n-- результат: [1, 1, 3, 4, 5]\n```\n\nС компаратором:\n\n```yqls\n(let points (AsList\n    (AsStruct '('x (Int32 '3)) '('y (Int32 '4)))\n    (AsStruct '('x (Int32 '1)) '('y (Int32 '2)))\n))\n(let sorted (Sort points (lambda '(a b)\n    (let dx (Sub (Member a 'x) (Member b 'x)))\n    (if (NotEqual dx (Int32 '0)) dx\n        (Sub (Member a 'y) (Member b 'y))\n    )\n)))\n```\n\n---",
    "GroupByKey": "**Аргументы**:\n\n| collection | keySelector |\n| --- | --- |\n| List<T> | Callable(T) -> K |\n\n**Возвращаемое значение**: Dict<K, List<T>>\n\nГруппирует элементы по ключу.\n\n```yqls\n(let people (AsList\n    (AsStruct '('name (String 'Alice)) '('age (Uint32 '25)))\n    (AsStruct '('name (String 'Bob)) '('age (Uint32 '25)))\n    (AsStruct '('name (String 'Charlie)) '('age (Uint32 '30)))\n))\n(let grouped (GroupByKey people (lambda '(p) (Member p 'age))))\n-- результат: {25: [...], 30: [...]}\n```\n\n---",
    "Fold": "**Аргументы**:\n\n| collection | initial | folder |\n| --- | --- | --- |\n| List<T> | R | Callable(R, T) -> R |\n\n**Возвращаемое значение**: R\n\nСвёртка слева.\n\n```yqls\n(let nums (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3) (Uint32 '4)))\n(let sum (Fold nums (Uint32 '0) (lambda '(acc x) (Add acc x))))\n-- результат: 10\n```\n\n---",
    "CombineByKey": "**Аргументы**:\n\n| collection | createCombiner | mergeValue | mergeCombiners | keySelector |\n| --- | --- | --- | --- | --- |\n| List<T> | Callable(V) -> C | Callable(C, V) -> C | Callable(C, C) -> C | Callable(T) -> K |\n\n**Возвращаемое значение**: Dict<K, C>\n\nОбобщённая агрегация по ключам.\n\n```yqls\n(let data (AsList\n    (AsTuple (String 'A) (Uint32 '1))\n    (AsTuple (String 'B) (Uint32 '1))\n    (AsTuple (String 'A) (Uint32 '1))\n))\n(let result (CombineByKey data\n    (lambda '(v) (Uint32 '1))                    -- create\n    (lambda '(c v) (Add c (Uint32 '1)))          -- merge value\n    (lambda '(c1 c2) (Add c1 c2))                -- merge combiners\n    (lambda '(x) (Nth x (Uint32 '0)))            -- key = первый элемент\n))\n-- результат: {\"A\": 2, \"B\": 1}\n```\n\n---",
    "Insert": "**Аргументы**:\n\n| collection | index | value |\n| --- | --- | --- |\n| List<T> | Uint32 | T |\n\n**Возвращаемое значение**: List<T>\n\nВставляет значение по индексу.\n\n```yqls\n(let lst (AsList (Int32 '10) (Int32 '20) (Int32 '40)))\n(let result (Insert lst (Uint32 '2) (Int32 '30)))\n-- результат: [10, 20, 30, 40]\n```\n\n---",
    "Append": "**Аргументы**:\n\n| collection | value |\n| --- | --- |\n| List<T> | T |\n\n**Возвращаемое значение**: List<T>\n\nДобавляет элемент в конец.\n\n```yqls\n(let lst (AsList (Int32 '1) (Int32 '2) (Int32 '3)))\n(let result (Append lst (Int32 '4)))\n-- результат: [1, 2, 3, 4]\n```\n\n---",
    "ToOptional": "**Аргументы**:\n\n| value |\n| --- |\n| T |\n\n**Возвращаемое значение**: Optional<T>\n\nОборачивает значение в `Optional`.\n\n```yqls\n(let opt (ToOptional (String 'hello)))\n-- результат: Just(\"hello\")\n```\n\n---",
    "Take": "**Аргументы**:\n\n| collection | count |\n| --- | --- |\n| List<T> | Uint32 |\n\n**Возвращаемое значение**: List<T>\n\nБерёт первые `count` элементов.\n\n```yqls\n(let nums (AsList (Int32 '1) (Int32 '2) (Int32 '3) (Int32 '4) (Int32 '5)))\n(let head (Take nums (Uint32 '3)))\n-- результат: [1, 2, 3]\n```\n\n---",
    "Extract": "**Аргументы**:\n\n| optionalValue |\n| --- |\n| Optional<T> |\n\n**Возвращаемое значение**: T\n\nИзвлекает значение из `Optional`. Поведение как у `Right!` — падает, если `None`.\n\n```yqls\n(let opt (Just (Int32 '100)))\n(let val (Extract opt)) -- возвращает 100\n```\n\n---\n\n> **Примечание**:\n> - Все функции возвращают **новые значения**, не изменяя исходные.\n> - Коллекции — неизменяемые.\n> - `lambda`, `AsList`, `AsStruct`, `AsDict`, `AsTuple`, `Member`, `Nth`, `Just`, `None` — стандартные конструкции YQLs.\n> - Типы: `Uint32`, `Int32`, `String`, `Bool`, `Optional`, `List`, `Dict`, `Struct`, `Tuple` — поддерживаются напрямую.\n\n---\n\n## Работа с типами и данными",
    "CallableType": "**Аргументы**:\n\n| arg1_type | arg2_type | ... | return_type |\n| --- | --- | --- | --- |\n| Type | Type | ... | Type |\n\n**Возвращаемое значение**: Type\n\nОпределяет тип вызываемого объекта (функции или лямбды), указывая типы его аргументов и возвращаемого значения.\n\n```yqls\n(let MyFuncType (CallableType (DataType 'String') (DataType 'Uint32') (DataType 'Bool')))\n-- Определяет тип функции, которая принимает String, Uint32 и возвращает Bool\n```\n\n---",
    "DataType": "**Аргументы**:\n\n| type_name |\n| --- |\n| String |\n\n**Возвращаемое значение**: Type\n\nСоздает объект типа из его строкового представления. Необходимо для явного указания типов в таких функциях, как `CallableType`.\n\n```yqls\n(let type_obj (DataType 'Int32'))\n-- возвращает объект, представляющий тип Int32\n```\n---",
    "ListType": "**Аргументы**:\n\n| item_type |\n| --- |\n| Type |\n\n**Возвращаемое значение**: Type\n\nСоздает тип списка для указанного типа элементов.\n\n```yqls\n(let string_list_type (ListType (DataType 'String')))\n-- возвращает объект, представляющий тип List<String>\n```\n\n---",
    "String": "**Аргументы**:\n\n| literal |\n| --- |\n| Строковое значение |\n\n**Возвращаемое значение**: String\n\nСоздает значение типа `String` из литерала.\n\n```yqls\n(let s (String 'hello world'))\n-- результат: \"hello world\"\n```\n\n---",
    "Int32": "**Аргументы**:\n\n| literal |\n| --- |\n| Числовое значение |\n\n**Возвращаемое значение**: Int32\n\nСоздает значение типа `Int32` (32-битное знаковое целое) из литерала.\n\n```yqls\n(let i (Int32 '-123'))\n-- результат: -123\n```\n\n---",
    "AsList": "**Аргументы**:\n\n| item1 | item2 | ... |\n| --- | --- | --- |\n| T | T | ... |\n\n**Возвращаемое значение**: List<T>\n\nСоздает список из переданных элементов. Все элементы должны быть одного типа.\n\n```yqls\n(let lst (AsList (Int32 '1') (Int32 '2') (Int32 '3')))\n-- результат: [1, 2, 3]\n```\n\n---",
    "AsStruct": "**Аргументы**:\n\n| (key1, value1) | (key2, value2) | ... |\n| --- | --- | --- |\n| Tuple<String, T1> | Tuple<String, T2> | ... |\n\n**Возвращаемое значение**: Struct\n\nСоздает структуру из пар `(ключ, значение)`. Ключи должны быть строковыми литералами.\n\n```yqls\n(let person (AsStruct\n    '('name (String 'Alice))\n    '('age (Uint32 '30'))\n))\n-- результат: {name: \"Alice\", age: 30}\n```\n\n---\n\n## Работа с коллекциями и последовательностями (продолжение)",
    "Key": "**Аргументы**:\n\n| member_name1 | [member_name2] | ... |\n| --- | --- | --- |\n| Atom | Atom | ... |\n\n**Возвращаемое значение**: Callable\n\nСинтаксический сахар для создания лямбда-функции, извлекающей одно или несколько полей из структуры. Особенно полезен в `GroupByKey` и `Sort`.\n\n```yqls\n(let data (AsList\n    (AsStruct '('city (String 'A)) '('val (Int32 '1)))\n    (AsStruct '('city (String 'B)) '('val (Int32 '2)))\n    (AsStruct '('city (String 'A)) '('val (Int32 '3)))\n))\n-- Группировка по полю 'city'\n(let grouped (GroupByKey data (Key 'city)))\n-- Эквивалентно: (GroupByKey data (lambda '(x) (Member x 'city)))\n-- результат: {\"A\": [{city:\"A\", val:1}, {city:\"A\", val:3}], \"B\": [...]}\n```\n\n---\n\n## Выполнение и вызовы",
    "Apply": "**Аргументы**:\n\n| callable | arg1 | arg2 | ... |\n| --- | --- | --- | --- |\n| Callable | T1 | T2 | ... |\n\n**Возвращаемое значение**: R (возвращаемый тип `callable`)\n\nПрименяет `callable` к переданным аргументам `arg1`, `arg2`, ...\n\n```yqls\n(let my_add (lambda '(a b) (Add a b)))\n(let result (Apply my_add (Int32 '5') (Int32 '10')))\n-- результат: 15\n```\n\n---\n\n## Определение функций и модулей",
    "ScriptUdf": "**Аргументы**:\n\n| language | function_name | callable_type | script_body |\n| --- | --- | --- | --- |\n| String | String | CallableType | String |\n\n**Возвращаемое значение**: Callable\n\nСоздает пользовательскую функцию (UDF) из скрипта на другом языке (например, Python). Это позволяет выполнять сложную логику, которую трудно или невозможно выразить на чистом YQLs.\n\n```yqls\n(let py_split (ScriptUdf 'python\n    'str_split                                         -- Имя функции в Python\n    (CallableType (DataType 'String') (DataType 'String') (ListType (DataType 'String'))) -- Тип: (str, sep) -> List[str]\n    (String '\ndef str_split(s, sep):\n    return s.split(sep)\n')))\n\n(let result (Apply py_split (String \"one,two,three\") (String \",\")))\n-- результат: [\"one\", \"two\", \"three\"]\n```\n\n---\n\n## Ввод/вывод и состояние",
    "DataSink": "**Аргументы**:\n\n| provider | cluster |\n| --- | --- |\n| String | String |\n\n**Возвращаемое значение**: DataSink\n\nСоздает объект-приемник данных, который указывает, куда будут записаны результаты. Используется в связке с `Write!` и `Commit!`.\n\n```yqls\n(let my_sink (DataSink 'yt' 'my_cluster'))\n-- Создает приемник для записи в YT кластер 'my_cluster'\n```\n\n---\n### Commit!\n**Аргументы**:\n\n| world | sink | [options] |\n| --- | --- | --- |\n| World | DataSink | CommitOptions |\n\n**Возвращаемое значение**: World\n\nФиксирует все отложенные операции записи для указанного `sink`. Это действие с побочным эффектом, которое изменяет состояние внешнего мира.\n\n```yqls\n(let world (Commit! world my_sink (CommitOptions)))\n-- Фиксирует изменения для приемника 'my_sink', возвращая новое состояние 'world'\n```\n\n---\n\n### ResFill!\n**Аргументы**:\n\n| world | tag_name | value |\n| --- | --- | --- |\n| World | String | T |\n\n**Возвращаемое значение**: World\n\nЗаписывает `value` в именованный \"ресурсный тег\". Это простой способ передать скалярный результат вычисления из YQL-скрипта во внешнюю систему без использования полноценной таблицы для вывода.\n\n```yqls\n(let world (ResFill! world (String 'my_result_tag') (String 'Computation finished successfully')))\n-- Записывает строку в ресурсный тег \"my_result_tag\"\n```"
}
