{
    "TakeWhileInclusive": "**Аргументы**:\n\n| collection | predicate |\n| --- | --- |\n| List<T> | Callable(T) -> Bool |\n\n**Возвращаемое значение**: List<T>\n\nВозвращает элементы с начала списка, пока `predicate` возвращает `True`, **включая первый элемент, для которого `predicate` стал `False`**.\n\n```yqls\n(let nums (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3) (Uint32 '4) (Uint32 '5) (Uint32 '2)))\n(let result (TakeWhileInclusive nums (lambda '(x) (< x (Uint32 '4)))))\n-- результат: [1, 2, 3, 4]\n```\n\n---",
    "SkipWhileInclusive": "**Аргументы**:\n\n| collection | predicate |\n| --- | --- |\n| List<T> | Callable(T) -> Bool |\n\n**Возвращаемое значение**: List<T>\n\nПропускает элементы с начала, пока `predicate` возвращает `True`, **включая первый элемент, для которого `predicate` вернул `False`**.\n\n```yqls\n(let nums (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3) (Uint32 '4) (Uint32 '5) (Uint32 '6)))\n(let result (SkipWhileInclusive nums (lambda '(x) (< x (Uint32 '4)))))\n-- результат: [5, 6]\n```\n\n---",
    "FlatMap": "**Аргументы**:\n\n| collection | transformer |\n| --- | --- |\n| List<T> | Callable(T) -> List<R> |\n\n**Возвращаемое значение**: List<R>\n\nПрименяет `transformer` к каждому элементу и объединяет результаты в один плоский список.\n\n```yqls\n(let lists (AsList\n    (AsList (Uint32 '1) (Uint32 '2))\n    (AsList (Uint32 '3))\n    (AsList (Uint32 '4) (Uint32 '5))\n))\n(let result (FlatMap lists (lambda '(x) x)))\n-- результат: [1, 2, 3, 4, 5]\n```\n\n---",
    "OrderedFlatMap": "**Аргументы**:\n\n| collection | transformer |\n| --- | --- |\n| List<T> | Callable(T) -> List<R> |\n\n**Возвращаемое значение**: List<R>\n\nАналог `FlatMap`, но гарантирует **сохранение порядка** элементов даже при параллельной обработке.\n\n```yqls\n(let items (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3)))\n(let result (OrderedFlatMap items (lambda '(x)\n    (AsList x (Add x (Uint32 '1)))\n)))\n-- результат: [1, 2, 2, 3, 3, 4]\n```\n\n---",
    "StaticMap": "**Аргументы**:\n\n| collection | mapping |\n| --- | --- |\n| List<T> | Dict<T, R> |\n\n**Возвращаемое значение**: List<Optional<R>>\n\nПреобразует каждый элемент по словарю. Если элемент отсутствует в словаре — результат `None`.\n\n```yqls\n(let keys (AsList (String 'Alice) (String 'Bob) (String 'Charlie)))\n(let dict (AsDict\n    (AsTuple (String 'Alice) (String 'A))\n    (AsTuple (String 'Bob) (String 'B))\n))\n(let result (StaticMap keys dict))\n-- результат: [Just(\"A\"), Just(\"B\"), None]\n```\n\n---",
    "StaticZip": "**Аргументы**:\n\n| collection1 | collection2 | ... |\n| --- | --- | --- |\n| List<T1> | List<T2> | ... |\n\n**Возвращаемое значение**: List<Tuple<T1, T2, ...>>\n\nСоединяет списки по индексам. Длина результата — по самому короткому.\n\n```yqls\n(let nums (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3)))\n(let letters (AsList (String 'a) (String 'b) (String 'c) (String 'd)))\n(let result (StaticZip nums letters))\n-- результат: [(1,\"a\"), (2,\"b\"), (3,\"c\")]\n```\n\n---",
    "Sort": "**Аргументы**:\n\n| collection | [comparator] |\n| --- | --- |\n| List<T> | Callable(T, T) -> Int |\n\n**Возвращаемое значение**: List<T>\n\nСортирует список. Без `comparator` — по естественному порядку.\n\n```yqls\n(let unsorted (AsList (Int32 '3) (Int32 '1) (Int32 '4) (Int32 '1) (Int32 '5)))\n(let sorted (Sort unsorted))\n-- результат: [1, 1, 3, 4, 5]\n```\n\nС компаратором:\n\n```yqls\n(let points (AsList\n    (AsStruct '('x (Int32 '3)) '('y (Int32 '4)))\n    (AsStruct '('x (Int32 '1)) '('y (Int32 '2)))\n))\n(let sorted (Sort points (lambda '(a b)\n    (let dx (Sub (Member a 'x) (Member b 'x)))\n    (if (NotEqual dx (Int32 '0)) dx\n        (Sub (Member a 'y) (Member b 'y))\n    )\n)))\n```\n\n---",
    "GroupByKey": "**Аргументы**:\n\n| collection | keySelector |\n| --- | --- |\n| List<T> | Callable(T) -> K |\n\n**Возвращаемое значение**: Dict<K, List<T>>\n\nГруппирует элементы по ключу.\n\n```yqls\n(let people (AsList\n    (AsStruct '('name (String 'Alice)) '('age (Uint32 '25)))\n    (AsStruct '('name (String 'Bob)) '('age (Uint32 '25)))\n    (AsStruct '('name (String 'Charlie)) '('age (Uint32 '30)))\n))\n(let grouped (GroupByKey people (lambda '(p) (Member p 'age))))\n-- результат: {25: [...], 30: [...]}\n```\n\n---",
    "Fold": "**Аргументы**:\n\n| collection | initial | folder |\n| --- | --- | --- |\n| List<T> | R | Callable(R, T) -> R |\n\n**Возвращаемое значение**: R\n\nСвёртка слева.\n\n```yqls\n(let nums (AsList (Uint32 '1) (Uint32 '2) (Uint32 '3) (Uint32 '4)))\n(let sum (Fold nums (Uint32 '0) (lambda '(acc x) (Add acc x))))\n-- результат: 10\n```\n\n---",
    "CombineByKey": "**Аргументы**:\n\n| collection | createCombiner | mergeValue | mergeCombiners | keySelector |\n| --- | --- | --- | --- | --- |\n| List<T> | Callable(V) -> C | Callable(C, V) -> C | Callable(C, C) -> C | Callable(T) -> K |\n\n**Возвращаемое значение**: Dict<K, C>\n\nОбобщённая агрегация по ключам.\n\n```yqls\n(let data (AsList\n    (AsTuple (String 'A) (Uint32 '1))\n    (AsTuple (String 'B) (Uint32 '1))\n    (AsTuple (String 'A) (Uint32 '1))\n))\n(let result (CombineByKey data\n    (lambda '(v) (Uint32 '1))                    -- create\n    (lambda '(c v) (Add c (Uint32 '1)))          -- merge value\n    (lambda '(c1 c2) (Add c1 c2))                -- merge combiners\n    (lambda '(x) (Nth x (Uint32 '0)))            -- key = первый элемент\n))\n-- результат: {\"A\": 2, \"B\": 1}\n```\n\n---",
    "Insert": "**Аргументы**:\n\n| collection | index | value |\n| --- | --- | --- |\n| List<T> | Uint32 | T |\n\n**Возвращаемое значение**: List<T>\n\nВставляет значение по индексу.\n\n```yqls\n(let lst (AsList (Int32 '10) (Int32 '20) (Int32 '40)))\n(let result (Insert lst (Uint32 '2) (Int32 '30)))\n-- результат: [10, 20, 30, 40]\n```\n\n---",
    "Append": "**Аргументы**:\n\n| collection | value |\n| --- | --- |\n| List<T> | T |\n\n**Возвращаемое значение**: List<T>\n\nДобавляет элемент в конец.\n\n```yqls\n(let lst (AsList (Int32 '1) (Int32 '2) (Int32 '3)))\n(let result (Append lst (Int32 '4)))\n-- результат: [1, 2, 3, 4]\n```\n\n---",
    "ToOptional": "**Аргументы**:\n\n| value |\n| --- |\n| T |\n\n**Возвращаемое значение**: Optional<T>\n\nОборачивает значение в `Optional`.\n\n```yqls\n(let opt (ToOptional (String 'hello)))\n-- результат: Just(\"hello\")\n```\n\n---",
    "Take": "**Аргументы**:\n\n| collection | count |\n| --- | --- |\n| List<T> | Uint32 |\n\n**Возвращаемое значение**: List<T>\n\nБерёт первые `count` элементов.\n\n```yqls\n(let nums (AsList (Int32 '1) (Int32 '2) (Int32 '3) (Int32 '4) (Int32 '5)))\n(let head (Take nums (Uint32 '3)))\n-- результат: [1, 2, 3]\n```\n\n---",
    "Extract": "**Аргументы**:\n\n| optionalValue |\n| --- |\n| Optional<T> |\n\n**Возвращаемое значение**: T\n\nИзвлекает значение из `Optional`. Поведение как у `Right!` — падает, если `None`.\n\n```yqls\n(let opt (Just (Int32 '100)))\n(let val (Extract opt)) -- возвращает 100\n```\n\n---\n\n> **Примечание**:\n> - Все функции возвращают **новые значения**, не изменяя исходные.\n> - Коллекции — неизменяемые.\n> - `lambda`, `AsList`, `AsStruct`, `AsDict`, `AsTuple`, `Member`, `Nth`, `Just`, `None` — стандартные конструкции YQLs.\n> - Типы: `Uint32`, `Int32`, `String`, `Bool`, `Optional`, `List`, `Dict`, `Struct`, `Tuple` — поддерживаются напрямую."
}
